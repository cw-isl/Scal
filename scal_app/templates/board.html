
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Smart Frame</title>
<style>
  :root { --W:1080px; --H:1920px; --top:90px; --cal:1020px;
          --weather:320px; --layout-left:460px; --section-gap:26px;
          --section-card-gap:calc(var(--section-gap) - 4px); }

  /* Global layout */
  html,body { margin:0; padding:0; background:transparent; color:#fff; font-family:system-ui,-apple-system,Roboto,'Noto Sans KR',sans-serif; }
  .frame-wrapper { width:var(--W); min-height:var(--H); margin:0 auto; position:relative; }
  .frame { width:var(--W); min-height:var(--H); display:flex; flex-direction:column; position:relative; }

  /* Background photo crossfade */
  .bg, .bg2 {
    position: absolute;
    top: 50%;
    left: 50%;
    z-index: -1;
    width: var(--W);
    height: var(--H);
    max-width: var(--W);
    max-height: var(--H);
    transform: translate(-50%, -50%);
    object-fit: contain;
    object-position: center;
    background-size: contain;
    background-position: center center;
    background-repeat: no-repeat;
    background-color:#000;
    transition: opacity 1s ease;
    pointer-events: none;
    aspect-ratio: var(--W) / var(--H);
  }
  .bg.bg-landscape,
  .bg.bg-portrait,
  .bg.bg-sideways,
  .bg2.bg-landscape,
  .bg2.bg-portrait,
  .bg2.bg-sideways {
    width: var(--W);
    height: var(--H);
    max-width: var(--W);
    max-height: var(--H);
  }
  .bg2 { opacity: 0; }

  .top { height:var(--top); display:flex; align-items:center; justify-content:space-between; padding:0 24px; box-sizing:border-box; }
  .top-right { display:flex; align-items:center; gap:12px; }
  .time { font-size:38px; font-weight:700; letter-spacing:1px; text-shadow:0 0 6px rgba(0,0,0,.65);}
  .date { font-size:22px; opacity:.95; text-shadow:0 0 6px rgba(0,0,0,.65);}
  .refresh-btn {
    width:34px;
    height:34px;
    border-radius:50%;
    border:1px solid rgba(255,255,255,.35);
    background:rgba(0,0,0,.35);
    color:#fff;
    font-size:16px;
    cursor:pointer;
    display:flex;
    align-items:center;
    justify-content:center;
    transition:background .2s ease, border-color .2s ease;
    box-shadow:0 0 6px rgba(0,0,0,.45);
  }
  .refresh-btn:hover,
  .refresh-btn:focus {
    background:rgba(255,255,255,.18);
    border-color:rgba(255,255,255,.6);
    outline:none;
    box-shadow:0 0 0 2px rgba(255,255,255,.25);
  }
  .refresh-btn:active {
    transform:scale(.96);
  }

  .cal { height:auto; min-height:var(--cal); padding:8px 20px calc(var(--section-gap)/2); box-sizing:border-box; display:flex; flex-direction:column; }
  .cal h2 { margin:0 0 8px 0; font-size:22px; opacity:.95; display:flex; align-items:center; gap:8px; text-shadow:0 0 6px rgba(0,0,0,.65);}

  .grid { flex:1 1 auto; display:grid; grid-template-columns: repeat(7, 1fr); grid-auto-rows: 1fr; gap:6px; }
  .dow { display:grid; grid-template-columns: repeat(7, 1fr); margin-bottom:6px; opacity:.95; font-size:14px; text-shadow:0 0 6px rgba(0,0,0,.65);}
  .dow div { text-align:center; }

  /* Calendar cells */
  .cell { border:1px solid rgba(255,255,255,.12); border-radius:10px; padding:6px;
          background:rgba(0,0,0,.35); display:flex; flex-direction:column; overflow:hidden;}
  .cell.dim { opacity:.45; }
  .dnum { font-size:14px; opacity:.95; margin-bottom:4px; text-shadow:0 0 6px rgba(0,0,0,.65);}
  .ev { font-size:12px; line-height:1.25; margin:2px 0;
        background:rgba(0,0,0,.45); border-radius:6px; padding:2px 6px;
        white-space:nowrap; overflow:hidden; text-overflow:ellipsis; text-shadow:0 0 6px rgba(0,0,0,.65);
        transition:background .2s ease, color .2s ease;}
  .ev.has-color { text-shadow:none; font-weight:600; }

  .section {
    position:relative;
    min-height:auto;
    height:auto;
    padding:calc(var(--section-gap)/2) 24px var(--section-gap);
    box-sizing:border-box;
    display:flex;
    flex-direction:column;
    gap:var(--section-gap);
  }

  .section-upper {
    display:grid;
    grid-template-columns:minmax(0, var(--layout-left)) minmax(0, 1fr);
    gap:var(--section-card-gap);
    align-items:stretch;
  }

  .section-left {
    display:flex;
    flex-direction:column;
    gap:var(--section-card-gap);
  }

  .section-right {
    display:flex;
    flex-direction:column;
    gap:var(--section-card-gap);
    border-left:none;
    padding-left:0;
  }

  .blk { background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:16px 18px; }
  .blk h3 { margin:0 0 6px 0; font-size:16px; opacity:.95; text-shadow:0 0 6px rgba(0,0,0,.65);}

.todo{ display:flex; flex-direction:column; height:100%; min-height:170px; }
  .todo .rows { display:grid; grid-template-columns: 1fr 1fr; gap:8px; flex:1 1 auto; }
  .todo .col { display:flex; flex-direction:column; gap:6px; min-width:0; }
.todo .item { display:flex; align-items:center; gap:10px; font-size:14px; padding:4px 6px; border-radius:8px; }
.todo .item.overdue { background:rgba(255,75,75,0.12); }
.todo .title { flex:1 1 auto; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
.todo .due { opacity:.9; min-width:56px; margin-left:auto; font-weight:600; text-align:right; }
.todo .item.overdue .due { color:#ffb4b4; }
.todo .message { font-size:13px; opacity:.85; padding:8px 10px; border-radius:10px; background:rgba(0,0,0,.25); }
.todo .message.error { color:#ffb4b4; }

  .bus{display:flex; flex-direction:column; gap:10px; background:rgba(0,0,0,.28); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:16px 18px; height:100%; min-height:190px;}
  .bus .arrivals{display:flex; flex-direction:column; gap:8px; min-width:0; flex:1 1 auto;}
  .bus .arrivals h3{margin-bottom:0;}
  .bus .stop{font-size:14px; margin-bottom:4px;}
  .bus .rows{display:flex; gap:10px; overflow:hidden;}
  .bus .col{flex:1 1 50%; display:flex; flex-direction:column; gap:6px;}
  .bus .item{display:flex; font-size:14px; white-space:nowrap;}
  .bus .item .rt{font-weight:700; width:8ch; white-space:nowrap;}
  .bus .item .hops{width:6ch; text-align:right; margin-right:4px; white-space:nowrap;}
  .bus .item .msg{flex:0 0 6ch; text-align:right; opacity:.9; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;}

  .home{display:flex; flex-direction:column; background:rgba(0,0,0,.28); border:1px solid rgba(255,255,255,.12); border-radius:12px; padding:20px 22px; min-height:360px; height:100%;}
  .home h3{margin-bottom:6px;}
  .home .ha-grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(150px,1fr)); gap:14px; flex:1 1 auto; align-content:start; overflow:auto; padding-bottom:6px;}
  body.rotate-90 .home .ha-grid,
  body.rotate-neg-90 .home .ha-grid{grid-template-columns:repeat(3,minmax(0,1fr));}
  .home .ha-device{display:flex; align-items:center; gap:14px; padding:18px 16px; border-radius:16px; background:rgba(0,0,0,.32); border:1px solid rgba(255,255,255,.12); transition:background .2s, border-color .2s, box-shadow .2s, transform .2s; cursor:pointer; user-select:none; min-height:82px;}
  .home .ha-device .icon{font-size:30px;}
  .home .ha-device .meta{display:flex; flex-direction:column; gap:6px; align-items:flex-start; min-width:0;}
  .home .ha-device .name{font-size:16px; font-weight:600; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width:100%;}
  .home .ha-device .state{font-size:14px; opacity:.9;}
  .home .ha-device .state.on{color:#96f7c5;}
  .home .ha-device .state.off{color:rgba(255,255,255,.82);}
  .home .ha-device.on{background:rgba(255,255,255,.12); border-color:rgba(150,247,197,.55); box-shadow:0 0 22px rgba(150,247,197,.35);}
  .home .ha-device.offline{opacity:.55; border-style:dashed; border-color:rgba(255,255,255,.25); cursor:default;}
  .home .ha-device.disabled{cursor:default; opacity:.7;}
  .home .ha-device.pending{pointer-events:none; opacity:.65;}
  .home .ha-device.offline .state{color:#ffb4b4;}
  .home .ha-status{grid-column:1 / -1; padding:12px 16px; border-radius:12px; background:rgba(0,0,0,.32); font-size:14px; text-align:center; line-height:1.4;}
  .home .ha-device:active{transform:scale(.97);}

  /* Verse block */
  .verse { flex:0 0 100px; display:flex; flex-direction:column; align-items:flex-start; }
  .verse .text { white-space:pre-wrap; line-height:1.4; font-size:16px; text-shadow:0 0 6px rgba(0,0,0,.65); }

/* Weather layout (card style 5-day forecast) */
  .weather {
    display:flex;
    gap:16px;
    align-items:stretch;
    flex-wrap:wrap;
    padding:14px 16px;
  }
  .weather .w-now {
    display:flex;
    align-items:center;
    gap:12px;
    min-width:220px;
    flex:0 0 auto;
  }
  .weather .w-now .info { display:flex; flex-direction:column; gap:6px; }
  .weather .w-now .temp { font-size:38px; font-weight:800; line-height:1; }
  .weather .w-now .meta { display:flex; flex-direction:column; gap:4px; font-size:14px; opacity:.9; }
  .weather .w-now .meta span { display:flex; align-items:center; gap:6px; }

  .weather .w-days {
    display:grid;
    grid-template-columns:repeat(5, minmax(0, 105px));
    gap:16px;
    justify-content:flex-start;
    flex:0 0 auto;
    margin-right:auto;
  }
  .weather .w-day {
    text-align:center;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.08);
    border-radius:12px;
    padding:6px 4px;
    width:105px;
  }
.weather .w-day.today { outline:2px solid rgba(255,255,255,.35); outline-offset:-2px; }
.weather .w-day img { width:52px; height:52px; display:block; margin:2px auto; }
.weather .w-day .temps { display:flex; justify-content:center; gap:6px; font-size:14px; margin-top:2px; }
.weather .w-day .hi { font-weight:800; font-size:16px; }
.weather .w-day .lo { opacity:.75; font-size:14px; }

/* ‚ñº AQI card on the right */
  .weather .w-aqi {
    width:105px;
    text-align:center;
    background:rgba(0,0,0,.25);
    border:1px solid rgba(255,255,255,.08);
    border-radius:12px;
    padding:10px 6px;
    display:flex;
    flex-direction:column;
    justify-content:center;
    gap:4px;
    flex:0 0 auto;
  }
.weather .w-aqi .ttl { font-size:12px; letter-spacing:.5px; opacity:.9; }
.weather .w-aqi .idx { font-size:24px; font-weight:800; line-height:1; }
.weather .w-aqi .lbl { font-size:14px; opacity:.9; }
.weather .w-aqi .pm { font-size:12px; opacity:.85; }

/* Background must stay behind content */
.bg, .bg2 { z-index:-1; }
.frame { position:relative; z-index:1; }

  /* Rotated (clockwise 90deg) layout */
  body.rotate-90 {
    width:var(--H);
    height:var(--W);
    overflow:hidden;
    touch-action:none;
  }
  body.rotate-90 .frame-wrapper {
    width:var(--H);
    height:var(--W);
    margin:0;
    position:absolute;
    top:0;
    left:var(--H);
    transform:rotate(90deg);
    transform-origin:top left;
    overflow:hidden;
  }
  body.rotate-90 .frame {
    width:var(--W);
    min-height:var(--H);
  }
  body.rotate-90 .bg,
  body.rotate-90 .bg2 {
    width: var(--W);
    height: var(--H);
    max-width: var(--W);
    max-height: var(--H);
  }

  /* Rotated (counter-clockwise 90deg / left) layout */
  body.rotate-neg-90 {
    width:var(--H);
    height:var(--W);
    overflow:hidden;
    touch-action:none;
  }
  body.rotate-neg-90 .frame-wrapper {
    width:var(--H);
    height:var(--W);
    margin:0;
    position:absolute;
    top:var(--W);
    left:0;
    transform:rotate(-90deg);
    transform-origin:top left;
    overflow:hidden;
  }
  body.rotate-neg-90 .frame {
    width:var(--W);
    min-height:var(--H);
  }
  body.rotate-neg-90 .bg,
  body.rotate-neg-90 .bg2 {
    width: var(--W);
    height: var(--H);
    max-width: var(--W);
    max-height: var(--H);
  }

</style>
</head>
<body>
<div class="frame-wrapper" id="frameWrapper">
<img class="bg" id="bg1" alt="" decoding="async"/>
<img class="bg2" id="bg2" alt="" decoding="async"/>

<div class="frame">
  <div class="top">
    <div class="date" id="datetxt">----</div>
    <div class="top-right">
      <div class="time" id="clock">--:--</div>
      <button type="button" class="refresh-btn" id="refreshButton" aria-label="ÏÉàÎ°úÍ≥†Ïπ®">‚Üª</button>
    </div>
  </div>

  <div class="cal">
    <h2 id="cal-title">Calendar</h2>
    <div class="dow"><div>Sun</div><div>Mon</div><div>Tue</div><div>Wed</div><div>Thu</div><div>Fri</div><div>Sat</div></div>
    <div class="grid" id="grid"></div>
  </div>

  <div class="section">
    <div class="section-upper">
      <div class="section-left">
        <div class="verse blk"><h3>Today's Verse</h3><div id="verse" class="text"></div></div>
        <div class="todo blk">
          <h3>Todo</h3>
          <div class="rows">
            <div class="col" id="todo-col-1"></div>
            <div class="col" id="todo-col-2"></div>
          </div>
        </div>
        <div class="bus blk">
          <div class="arrivals">
            <h3 id="bus-title">BUS Info</h3>
            <div class="stop" id="bus-stop"></div>
            <div class="rows" id="businfo">
              <div class="col" id="bus-left"></div>
              <div class="col" id="bus-right"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="section-right">
        <div class="home blk">
          <h3>Home Assistant</h3>
          <div class="ha-grid" id="ha-grid"></div>
        </div>
      </div>
    </div>
    <div class="weather blk" id="weather"></div>
  </div>
</div>
</div>

<script>
// Apply optional rotation when URL query contains rotate=right/cw/90 or left/ccw/-90
(function(){
  const params = new URLSearchParams(window.location.search);
  const rot = (params.get('rotate') || params.get('orientation') || '').toLowerCase();
  if (['90','90cw','cw','right','clockwise'].includes(rot)) {
    document.body.classList.add('rotate-90');
  } else if (['-90','90ccw','ccw','left','counterclockwise','270','270ccw','270cw'].includes(rot)) {
    document.body.classList.add('rotate-neg-90');
  }
})();

async function applyLayoutFromConfig(){
  const root = document.documentElement;
  const orientation = document.body.classList.contains('rotate-90')
    ? 'landscape_right'
    : (document.body.classList.contains('rotate-neg-90') ? 'landscape_left' : 'portrait');
  try {
    const res = await fetch(`/api/frame-layout?orientation=${orientation}`);
    if (!res.ok) throw new Error('layout load failed');
    const data = await res.json();
    const layout = data && data.layout ? data.layout : {};
    const map = {
      width: '--W',
      height: '--H',
      top: '--top',
      calendar: '--cal',
      weather: '--weather',
      layout_left: '--layout-left',
      section_gap: '--section-gap'
    };
    Object.entries(map).forEach(([key, cssVar]) => {
      if (layout[key] !== undefined && layout[key] !== null && !Number.isNaN(Number(layout[key]))) {
        const value = `${Number(layout[key])}px`;
        root.style.setProperty(cssVar, value);
        document.body.style.setProperty(cssVar, value);
      }
    });
  } catch (err) {
    console.warn('Failed to load frame layout settings:', err);
  }
}

applyLayoutFromConfig();

function z(n){return n<10?'0'+n:n}
function tick(){
  const d=new Date();
  const days=['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
  document.getElementById('clock').textContent = z(d.getHours())+":"+z(d.getMinutes());
  document.getElementById('datetxt').textContent = d.getFullYear()+"."+z(d.getMonth()+1)+"."+z(d.getDate())+" ("+days[d.getDay()]+")";
}
setInterval(tick, 1000); tick();

const refreshButton = document.getElementById('refreshButton');
if (refreshButton) {
  refreshButton.addEventListener('click', () => {
    window.location.reload();
  });
}

function startOfWeek(d){ const day=d.getDay(); const s=new Date(d); s.setDate(d.getDate()-day); s.setHours(0,0,0,0); return s; }

function pickTextColor(hex){
  if (!hex || typeof hex !== 'string' || !hex.startsWith('#')) return '#fff';
  let h = hex.slice(1);
  if (h.length === 3) h = h.split('').map(c => c + c).join('');
  if (h.length !== 6) return '#fff';
  const r = parseInt(h.slice(0,2),16);
  const g = parseInt(h.slice(2,4),16);
  const b = parseInt(h.slice(4,6),16);
  if ([r,g,b].some(n => Number.isNaN(n))) return '#fff';
  const brightness = (r * 299 + g * 587 + b * 114) / 1000;
  return brightness > 155 ? '#111' : '#fff';
}

function applyEventColor(el, color){
  if (!color) return;
  el.style.backgroundColor = color;
  el.style.color = pickTextColor(color);
  el.classList.add('has-color');
}

async function loadEvents(){
  const d=new Date();
  const y=d.getFullYear(), m=d.getMonth()+1;
  document.getElementById('cal-title').textContent = `Calendar  ${y}-${z(m)}`;
  let items = [];
  try {
    const r = await fetch(`/api/events?year=${y}&month=${m}`);
    if (!r.ok) throw new Error('failed');
    items = await r.json();
    if (!Array.isArray(items)) items = [];
  } catch (err) {
    console.error('Failed to load calendar events', err);
    items = [];
  }

  const byDay = {};
  for(const ev of items){
    const k = (ev.start||'').substring(0,10);
    (byDay[k]=byDay[k]||[]).push(ev);
  }

  const first = new Date(y, m-1, 1);
  let cur = startOfWeek(first);
  const grid = document.getElementById('grid'); grid.innerHTML='';
  let count = 0;
  while(count < 42){
    const cell = document.createElement('div');
    cell.className = 'cell' + ((cur.getMonth()+1!==m)?' dim':'');
    const key = `${cur.getFullYear()}-${z(cur.getMonth()+1)}-${z(cur.getDate())}`;
    const dn  = document.createElement('div'); dn.className='dnum'; dn.textContent = cur.getDate();
    cell.appendChild(dn);
    const arr = (byDay[key]||[]).slice(0,3);
    for(const ev of arr){
      const e=document.createElement('div'); e.className='ev'; e.textContent = ev.title || '(untitled)';
      if (ev.color) applyEventColor(e, ev.color);
      cell.appendChild(e);
    }
    grid.appendChild(cell);
    cur.setDate(cur.getDate()+1);
    count++;
  }
}
loadEvents(); setInterval(loadEvents, 5*60*1000);

function clearTodoColumns(){
  const c1=document.getElementById('todo-col-1');
  const c2=document.getElementById('todo-col-2');
  if (c1) c1.innerHTML='';
  if (c2) c2.innerHTML='';
  return [c1,c2];
}

function showTodoMessage(text, isError=false){
  const [c1,c2]=clearTodoColumns();
  if (!c1) return;
  const msg=document.createElement('div');
  msg.className='message'+(isError?' error':'');
  msg.textContent=text;
  c1.appendChild(msg);
}

function renderTodoItems(items){
  const [c1,c2]=clearTodoColumns();
  if (!c1 || !c2) return;
  const cols=[c1,c2];
  const limited=items.slice(0,8);
  limited.forEach((task, idx)=>{
    const row=document.createElement('div');
    row.className='item';
    if (task.overdue) row.classList.add('overdue');
    const title=document.createElement('div');
    title.className='title';
    title.textContent=task.title || '(untitled)';
    const due=document.createElement('div');
    due.className='due';
    due.textContent=task.due_label || '‚Äî';
    row.appendChild(title);
    row.appendChild(due);
    cols[idx % cols.length].appendChild(row);
  });
}

async function loadTodo(){
  try{
    const res=await fetch('/api/todo');
    const data=await res.json();
    if (!res.ok){
      throw new Error(data.error || 'failed');
    }
    if (data.need_config){
      showTodoMessage('ÏÑ§Ï†ï ÌôîÎ©¥ÏóêÏÑú Todoist API ÌÜ†ÌÅ∞ÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.');
      return;
    }
    if (data.error){
      showTodoMessage(data.error, true);
      return;
    }
    const items=Array.isArray(data.items)?data.items:[];
    if (!items.length){
      showTodoMessage('Ïò§ÎäòÏùÄ ÏôÑÎ£åÌï† ÏùºÏù¥ ÏóÜÏñ¥Ïöî!');
      return;
    }
    renderTodoItems(items);
  }catch(err){
    console.error('Failed to load todo list', err);
    showTodoMessage('Ìï† ÏùºÏùÑ Î∂àÎü¨Ïò§ÏßÄ Î™ªÌñàÏäµÎãàÎã§.', true);
  }
}

loadTodo(); setInterval(loadTodo, 60*1000);

// ===== Weather block (final: card-style 5-day forecast) =====
async function loadWeather() {
  const box = document.getElementById('weather');
  try {
    // ÎÇ†Ïî® + AQI ÎèôÏãú ÏöîÏ≤≠
    const [wr, ar] = await Promise.all([
      fetch('/api/weather'),
      fetch('/api/air')
    ]);

    const data = await wr.json();
    const air  = await ar.json().catch(()=>null);

    box.innerHTML = '';

    if (data && data.need_config) { box.textContent = 'OWM API Key required'; return; }
    if (!data || data.error)     { box.textContent = 'Weather error';       return; }

    // ÌòÑÏû¨(Ï¢åÏ∏°)
    const now = document.createElement('div');
    now.className = 'w-now';
    const current = data.current || {};
    const i = document.createElement('img');
    i.src = current.icon || ''; i.alt = ''; i.style.width='70px'; i.style.height='70px';
    const info = document.createElement('div'); info.className = 'info';
    const t = document.createElement('div');
    t.className = 'temp';
    const tempValue = (current.temp !== null && current.temp !== undefined) ? current.temp + '¬∞' : '‚Äì';
    t.textContent = tempValue;
    info.appendChild(t);

    const meta = document.createElement('div');
    meta.className = 'meta';
    const feels = current.feels_like;
    const humidity = current.humidity;
    const dew = current.dew_point;
    if (feels !== null && feels !== undefined) {
      const row = document.createElement('span');
      row.textContent = `Ï≤¥Í∞êÏò®ÎèÑ ${feels}¬∞`;
      meta.appendChild(row);
    }
    if (humidity !== null && humidity !== undefined) {
      const row = document.createElement('span');
      row.textContent = `ÏäµÎèÑ ${humidity}%`;
      meta.appendChild(row);
    }
    if (dew !== null && dew !== undefined) {
      const row = document.createElement('span');
      row.textContent = `Ïù¥Ïä¨Ï†ê ${dew}¬∞`;
      meta.appendChild(row);
    }
    if (meta.childElementCount > 0) info.appendChild(meta);

    now.appendChild(i);
    now.appendChild(info);

    // 5Ïùº Ïπ¥Îìú(Ï§ëÏïô) ‚Äî Îç∞Ïù¥ÌÑ∞Í∞Ä 7Ïùº ÏôÄÎèÑ 5Í∞úÎßå ÏÇ¨Ïö©
    const days = document.createElement('div');
    days.className = 'w-days';
    const names = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
    const todayIso = new Date().toISOString().slice(0,10);

    const fiveDays = (Array.isArray(data.days) ? data.days : []).slice(0, 5);
    for (const d of fiveDays) {
      const dt = new Date(d.date);
      const item = document.createElement('div');
      item.className = 'w-day';
      if (d.date === todayIso) item.classList.add('today');

      const nm = document.createElement('div'); nm.className='nm'; nm.textContent = names[dt.getDay()];
      const im = document.createElement('img'); im.src = d.icon; im.alt = '';
      const temps = document.createElement('div'); temps.className='temps';
      const hi = document.createElement('div'); hi.className='hi'; hi.textContent = d.max + '¬∞';
      const lo = document.createElement('div'); lo.className='lo'; lo.textContent = d.min + '¬∞';
      temps.appendChild(hi); temps.appendChild(lo);

      item.appendChild(nm); item.appendChild(im); item.appendChild(temps);
      days.appendChild(item);
    }

    // AQI Ïπ¥Îìú(Ïö∞Ï∏° ÎÅù)
    const aqiCard = document.createElement('div');
    aqiCard.className = 'w-aqi';
    const ttl = document.createElement('div'); ttl.className='ttl'; ttl.textContent = 'AQI';
    const idx = document.createElement('div'); idx.className='idx';
    const lbl = document.createElement('div'); lbl.className='lbl';
    const pm25 = document.createElement('div'); pm25.className='pm pm25';
    const pm10 = document.createElement('div'); pm10.className='pm pm10';

    if (air && !air.error && !air.need_config) {
      idx.textContent = air.aqi != null ? String(air.aqi) : '?';
      lbl.textContent = air.label || '';
      if (air.color) {
        aqiCard.style.boxShadow = `inset 0 0 0 2px ${air.color}`;
        aqiCard.style.color = '#fff';
      }
      if (air.pm2_5 != null) pm25.textContent = 'PM2.5 ' + Math.round(air.pm2_5);
      if (air.pm10  != null) pm10.textContent  = 'PM10 '  + Math.round(air.pm10);
    } else {
      idx.textContent = '‚Äì';
      lbl.textContent = 'n/a';
    }
    aqiCard.appendChild(ttl); aqiCard.appendChild(idx); aqiCard.appendChild(lbl);
    if (pm25.textContent) aqiCard.appendChild(pm25);
    if (pm10.textContent) aqiCard.appendChild(pm10);

    // Ï°∞Î¶Ω
    box.appendChild(now);
    box.appendChild(days);
    box.appendChild(aqiCard);

  } catch (e) {
    if (box) box.textContent = 'Failed to load weather';
  }
}
loadWeather();
setInterval(loadWeather, 10 * 60 * 1000);

// ===== Verse block =====
async function loadVerse(){
  try{
    const r = await fetch('/api/verse');
    const js = await r.json();
    document.getElementById('verse').textContent = js.text || '';
  }catch(e){
    document.getElementById('verse').textContent = '';
  }
}
loadVerse(); setInterval(loadVerse, 10*1000);

// ===== Home Assistant Ï†úÏñ¥ Ìå®ÎÑê =====
let haDevices = [];
const haDevicesState = { loading:false, needConfig:false, message:'', fetchError:'', commandError:'', dashboardTitle:'' };

function renderHomeControls(){
  const grid = document.getElementById('ha-grid');
  if(!grid) return;
  grid.innerHTML = '';

  const heading = document.querySelector('.home h3');
  if(heading){
    heading.textContent = haDevicesState.dashboardTitle ? `Home Assistant ¬∑ ${haDevicesState.dashboardTitle}` : 'Home Assistant';
  }

  const statuses = [];
  if(haDevicesState.needConfig){
    statuses.push(haDevicesState.message || 'Home Assistant Ïó∞Îèô ÏÑ§Ï†ïÏù¥ ÌïÑÏöîÌï©ÎãàÎã§.');
  }
  if(haDevicesState.fetchError){
    statuses.push('Î∂àÎü¨Ïò§Í∏∞ Ïò§Î•ò: ' + haDevicesState.fetchError);
  }
  if(haDevicesState.commandError){
    statuses.push('Î™ÖÎ†π Ïã§Ìå®: ' + haDevicesState.commandError);
  }
  if(!haDevicesState.needConfig && !haDevicesState.fetchError && haDevicesState.message){
    statuses.push(haDevicesState.message);
  }
  if(!haDevicesState.loading && !haDevicesState.needConfig && !haDevicesState.fetchError && haDevices.length === 0){
    statuses.push('ÌëúÏãúÌï† Í∏∞Í∏∞Í∞Ä ÏóÜÏäµÎãàÎã§.');
  }

  statuses.filter(Boolean).forEach(text => {
    const msg = document.createElement('div');
    msg.className = 'ha-status';
    msg.textContent = text;
    grid.appendChild(msg);
  });

  if(haDevicesState.needConfig){
    return;
  }
  if(haDevicesState.fetchError && haDevices.length === 0){
    return;
  }

  haDevices.forEach(dev => {
    const item = document.createElement('div');
    const isOn = dev.state && dev.state.on === true;
    const isOnline = dev.online !== false;
    const canToggle = dev.can_toggle === true && isOnline;
    const isPending = dev.pending === true;
    item.className = 'ha-device' + (isOn ? ' on' : '');
    if(!isOnline) item.className += ' offline';
    if(!canToggle) item.className += ' disabled';
    if(isPending) item.className += ' pending';
    item.dataset.id = dev.id || '';
    item.setAttribute('role', 'button');
    item.setAttribute('aria-pressed', String(!!isOn));
    const tooltip = [dev.name || dev.id || '', dev.room || '', dev.state_label || ''].filter(Boolean).join(' ¬∑ ');
    if(tooltip) item.title = tooltip;

    const icon = document.createElement('div');
    icon.className = 'icon';
    icon.textContent = dev.icon || 'üîò';

    const meta = document.createElement('div');
    meta.className = 'meta';

    const name = document.createElement('div');
    name.className = 'name';
    const room = dev.room ? ` ¬∑ ${dev.room}` : '';
    name.textContent = (dev.name || dev.id || 'Í∏∞Í∏∞') + room;

    const state = document.createElement('div');
    state.className = 'state';
    if(!isPending && isOnline){
      state.classList.add(isOn ? 'on' : 'off');
    }
    state.textContent = isPending ? 'ÎèôÏûë Ï§ë‚Ä¶' : (dev.state_label || (isOn ? 'ÏºúÏßê' : 'Í∫ºÏßê'));

    meta.appendChild(name);
    meta.appendChild(state);

    item.appendChild(icon);
    item.appendChild(meta);

    if(canToggle){
      item.addEventListener('click', () => toggleHADevice(dev));
    }

    grid.appendChild(item);
  });
}

async function loadHomeDevices(){
  haDevicesState.loading = true;
  haDevicesState.fetchError = '';
  haDevicesState.message = '';
  renderHomeControls();
  try{
    const r = await fetch('/api/home-devices');
    if(!r.ok){
      throw new Error('HTTP ' + r.status);
    }
    const data = await r.json();
    haDevicesState.dashboardTitle = data.dashboard && data.dashboard.title ? data.dashboard.title : '';
    if(data.need_config){
      haDevices = [];
      haDevicesState.needConfig = true;
      haDevicesState.message = data.message || 'Home Assistant Ïó∞ÎèôÏùÑ ÏÑ§Ï†ïÌïòÏÑ∏Ïöî.';
      haDevicesState.dashboardTitle = '';
      return;
    }
    haDevicesState.needConfig = false;
    haDevicesState.commandError = '';
    if(data.error){
      throw new Error(data.error);
    }
    haDevices = Array.isArray(data.devices) ? data.devices : [];
    if(data.message){
      haDevicesState.message = data.message;
    }
  }catch(e){
    haDevices = [];
    haDevicesState.fetchError = (e && e.message) ? e.message : 'Ïïå Ïàò ÏóÜÎäî Ïò§Î•ò';
    haDevicesState.dashboardTitle = '';
  }finally{
    haDevicesState.loading = false;
    renderHomeControls();
  }
}

async function toggleHADevice(dev){
  if(!dev || dev.pending || dev.can_toggle !== true || dev.online === false){
    return;
  }
  const desired = !(dev.state && dev.state.on === true);
  dev.pending = true;
  dev.state = Object.assign({}, dev.state, { on: desired });
  dev.state_label = desired ? 'ÏºúÏßê' : 'Í∫ºÏßê';
  renderHomeControls();
  try{
    const r = await fetch(`/api/home-devices/${encodeURIComponent(dev.id)}/execute`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ on: desired })
    });
    if(!r.ok){
      const err = await r.json().catch(()=>({}));
      throw new Error(err.error || ('HTTP ' + r.status));
    }
    haDevicesState.commandError = '';
  }catch(e){
    haDevicesState.commandError = (e && e.message) ? e.message : 'Ïã§Ìñâ Ïã§Ìå®';
  }finally{
    dev.pending = false;
    await loadHomeDevices();
  }
}

loadHomeDevices();
setInterval(loadHomeDevices, 30*1000);

async function refreshBus(){
  try{
    const r = await fetch('/api/bus');
    if(!r.ok) return;
    const data = await r.json();
    const titleEl = document.getElementById('bus-title');
    if(titleEl) titleEl.textContent = data.title || 'Î≤ÑÏä§ÎèÑÏ∞©';
    const stopEl = document.getElementById('bus-stop');
    if(stopEl) stopEl.textContent = data.stop || '';

    const left = document.getElementById('bus-left');
    const right = document.getElementById('bus-right');
    if(!left || !right) return;

    left.innerHTML='';
    right.innerHTML='';

    const rows = data.rows || [];
    if(!rows.length){
      left.textContent = 'Ï†ïÎ≥¥ ÏóÜÏùå';
      return;
    }
    if(rows.length===1 && rows[0].text && !rows[0].route){
      left.textContent = rows[0].text;
      return;
    }
    const mid = Math.ceil(rows.length/2);
    rows.slice(0, mid).forEach(it=>{
      const row=document.createElement('div');
      row.className='item';
      row.innerHTML=`<div class="rt">${it.route}</div><div class="hops">${it.hops}</div><div class="msg">${it.eta}</div>`;
      left.appendChild(row);
    });
    rows.slice(mid).forEach(it=>{
      const row=document.createElement('div');
      row.className='item';
      row.innerHTML=`<div class="rt">${it.route}</div><div class="hops">${it.hops}</div><div class="msg">${it.eta}</div>`;
      right.appendChild(row);
    });
  }catch(e){}
}
refreshBus();
setInterval(refreshBus,60000);

// ===== Background photo crossfade (delay-optimized & path-safe) =====
// - /api/photos Î™©Î°ù ÏÖîÌîå
// - ÏÑ∏Í∑∏Î®ºÌä∏Î≥Ñ URL Ïù∏ÏΩîÎî©(ÌïòÏúÑ Ìè¥Îçî Ïú†ÏßÄ)
// - Image().decode()Î°ú ÎØ∏Î¶¨ ÎîîÏΩîÎìú ÌõÑ Ï†ÑÌôò
// - Ï¥àÍ∏∞ Ìïú Ïû•ÏùÄ ÌôîÎ©¥Ïóê Î∞îÎ°ú ÏÑ∏ÌåÖÌïòÍ≥† ÌÅêÏóêÏÑú ÏÜåÎπÑ ‚Üí Ï≤´ Ï†ÑÌôò Ï¶âÏãú Îã§Î•∏ ÏÇ¨ÏßÑ
// - ÌÉ≠ ÎπÑÌôúÏÑ±Ìôî Ïãú ÌÉÄÏù¥Î®∏ ÏùºÏãúÏ§ëÏßÄ

let photoList = [];
let pi = 0;           // ÏÇ¨ÏßÑ Ïù∏Îç±Ïä§
let front = 1;        // ÌòÑÏû¨ Î≥¥Ïù¥Îäî Î†àÏù¥Ïñ¥: 1=bg1, 2=bg2
let photoSignature = '';

const DISPLAY_INTERVAL_MS = 5000;
const PRELOAD_MIN_COUNT   = 2;
const PRELOAD_COOLDOWN_MS = 250;
const PHOTO_REFRESH_INTERVAL_MS = 30000;

let preloadQueue = [];     // [{ url, readyAt, orientation, width, height }]
let isPreloading = false;
let nextSwitchAt = 0;
let slideTimer = null;
let refillTimer = null;
let isRefreshingPhotos = false;
const exifOrientationCache = new Map();

// --- Ïú†Ìã∏: ÏÑ∏Í∑∏Î®ºÌä∏Î≥Ñ Ïù∏ÏΩîÎî©(ÌïòÏúÑ Ìè¥Îçî Ïú†ÏßÄ) -------------------------------
function buildPhotoUrl(name){
  // "a/b c.jpg" -> "/photos/a/b%20c.jpg"
  return '/photos/' + String(name).split('/').map(encodeURIComponent).join('/');
}

// --- Ïú†Ìã∏: Î∞∞Ïó¥ ÏÖîÌîå -------------------------------------------------------
function shuffle(arr){
  for (let i = arr.length - 1; i > 0; i--){
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}

function isExifOrientationSideways(exifOrientation){
  return exifOrientation === 5 || exifOrientation === 6 || exifOrientation === 7 || exifOrientation === 8;
}

function determineOrientation(width, height, exifOrientation){
  if (isExifOrientationSideways(exifOrientation)){
    return 'sideways';
  }
  if (!width || !height) return 'portrait';
  return width >= height ? 'landscape' : 'portrait';
}

async function readExifOrientation(url){
  if (!url) return null;
  if (exifOrientationCache.has(url)){
    return exifOrientationCache.get(url);
  }

  try{
    const buffer = await fetchExifBytes(url);
    const orientation = extractExifOrientation(new DataView(buffer));
    exifOrientationCache.set(url, orientation);
    return orientation;
  }catch(err){
    console.warn('[photos] exif parse failed:', err);
    exifOrientationCache.set(url, null);
    return null;
  }
}

async function fetchExifBytes(url){
  let partialResponse = null;
  try{
    partialResponse = await fetch(url, { headers: { Range: 'bytes=0-65535' } });
  }catch(e){
    partialResponse = null;
  }

  if (partialResponse){
    if (partialResponse.status === 206 || partialResponse.status === 200){
      return partialResponse.arrayBuffer();
    }
    if (partialResponse.status !== 416){
      throw new Error(`HTTP ${partialResponse.status}`);
    }
  }

  const fullResponse = await fetch(url);
  if (!fullResponse.ok){
    throw new Error(`HTTP ${fullResponse.status}`);
  }
  return fullResponse.arrayBuffer();
}

function extractExifOrientation(view){
  if (!view || view.byteLength < 4) return null;
  let offset = 0;
  const length = view.byteLength;

  if (view.getUint16(offset) !== 0xffd8){
    return null;
  }
  offset += 2;

  while (offset + 4 <= length){
    const marker = view.getUint16(offset);
    offset += 2;

    const size = view.getUint16(offset);
    offset += 2;
    if (size < 2 || offset + size - 2 > length){
      break;
    }

    if (marker === 0xffe1){
      const exifHeader = getString(view, offset, 4);
      if (exifHeader === 'Exif'){
        const orientation = parseExifBlock(view, offset + 6, size - 8);
        if (orientation) return orientation;
      }
    }

    offset += size - 2;
  }

  return null;
}

function getString(view, start, length){
  let out = '';
  for (let i = 0; i < length && start + i < view.byteLength; i++){
    const charCode = view.getUint8(start + i);
    if (charCode === 0) break;
    out += String.fromCharCode(charCode);
  }
  return out;
}

function parseExifBlock(view, start, size){
  if (size <= 0 || start + size > view.byteLength) return null;

  const tiffStart = start;
  const byteOrder = view.getUint16(tiffStart);
  const littleEndian = byteOrder === 0x4949;
  if (!littleEndian && byteOrder !== 0x4d4d){
    return null;
  }

  const getUint16 = (pos)=> view.getUint16(pos, littleEndian);
  const getUint32 = (pos)=> view.getUint32(pos, littleEndian);

  if (getUint16(tiffStart + 2) !== 0x002a){
    return null;
  }

  const ifdOffset = getUint32(tiffStart + 4);
  if (ifdOffset < 8 || tiffStart + ifdOffset + 2 > view.byteLength){
    return null;
  }

  let dirOffset = tiffStart + ifdOffset;
  const numEntries = getUint16(dirOffset);
  dirOffset += 2;

  for (let i = 0; i < numEntries; i++){
    const entryOffset = dirOffset + i * 12;
    if (entryOffset + 12 > view.byteLength){
      break;
    }
    const tag = getUint16(entryOffset);
    if (tag === 0x0112){
      const value = getUint16(entryOffset + 8);
      if (value >= 1 && value <= 8){
        return value;
      }
    }
  }

  return null;
}

// --- Î™©Î°ù Î°úÎìú --------------------------------------------------------------
async function loadPhotos(force = false){
  try{
    const r = await fetch('/api/photos', { cache: 'no-store' });
    if (!r.ok){
      throw new Error(`HTTP ${r.status}`);
    }
    const list = await r.json();
    const photos = Array.isArray(list) ? list.slice() : [];
    const signature = photos.slice().sort().join('|');
    if (!force && signature === photoSignature){
      return false;
    }
    photoSignature = signature;
    photoList = photos;
    if (photoList.length){
      shuffle(photoList);
    }
    pi = 0;
    preloadQueue = [];
    return true;
  }catch(e){
    console.error('[photos] load failed:', e);
    if (force){
      photoList = [];
      preloadQueue = [];
      photoSignature = '';
    }
    return false;
  }
}

// --- Ïù¥ÎØ∏ÏßÄ 1Ïû• ÌîÑÎ¶¨Î°úÎìú(+decode) -----------------------------------------
function preloadOne(url){
  return new Promise((resolve)=>{
    const img = new Image();
    let done = false;
    const finalize = (result)=>{ if (!done){ done = true; resolve(result); } };
    const buildResult = ()=>({
      width: img.naturalWidth || img.width || 0,
      height: img.naturalHeight || img.height || 0
    });
    const orientationPromise = readExifOrientation(url).catch(()=>null);
    img.onload = ()=>{
      const result = buildResult();
      const afterDecode = ()=>{
        orientationPromise
          .then((exifOrientation)=>{
            result.exifOrientation = exifOrientation;
            finalize(result);
          })
          .catch(()=>finalize(result));
      };
      if (img.decode){
        img.decode().then(afterDecode).catch(afterDecode);
      }else{
        afterDecode();
      }
    };
    img.onerror = ()=> finalize(null);
    img.src = url;
  });
}

// --- ÌîÑÎ¶¨Î°úÎìú ÌÅê Î≥¥Ï∂© ------------------------------------------------------
async function ensurePreloaded(){
  if (isPreloading) return;
  isPreloading = true;
  try{
    while (preloadQueue.length < PRELOAD_MIN_COUNT && photoList.length){
      const name = photoList[pi % photoList.length]; pi++;
      const url  = buildPhotoUrl(name);
      const meta = await preloadOne(url);
      if (meta){
        const orientation = determineOrientation(meta.width, meta.height, meta.exifOrientation);
        preloadQueue.push({ url, readyAt: Date.now() + PRELOAD_COOLDOWN_MS, orientation, width: meta.width, height: meta.height });
      }
    }
  }finally{
    isPreloading = false;
  }
}

// --- Ïã§Ï†ú Ï†ÑÌôò --------------------------------------------------------------
function applyBackgroundOrientation(el, orientation){
  el.classList.remove('bg-landscape', 'bg-portrait', 'bg-sideways');
  if (orientation === 'landscape'){
    el.classList.add('bg-landscape');
  }else if (orientation === 'portrait'){
    el.classList.add('bg-portrait');
  }else if (orientation === 'sideways'){
    el.classList.add('bg-sideways');
  }
}

function applyBackgroundImage(el, photo){
  if (!el || !photo){
    return;
  }
  applyBackgroundOrientation(el, photo.orientation);
  if (el.tagName === 'IMG'){
    if (el.src !== photo.url){
      el.src = photo.url;
    }
  }else{
    el.style.backgroundImage = `url("${photo.url}")`;
  }
}

function primeHiddenLayer(){
  const next = preloadQueue[0];
  if (!next){
    return;
  }
  const hidden = document.getElementById(front === 1 ? 'bg2' : 'bg1');
  applyBackgroundImage(hidden, next);
  hidden.style.opacity = 0;
}

function swapBackground(photo){
  const incoming = document.getElementById(front === 1 ? 'bg2' : 'bg1'); // Îì§Ïñ¥Ïò¨ Î†àÏù¥Ïñ¥(ÌòÑÏû¨ Ìà¨Î™Ö)
  applyBackgroundImage(incoming, photo);
  // reflow
  incoming.offsetHeight;
  incoming.style.opacity = 1;

  const outgoing = document.getElementById(front === 1 ? 'bg1' : 'bg2'); // ÎÇòÍ∞à Î†àÏù¥Ïñ¥(ÌòÑÏû¨ Î≥¥ÏûÑ)
  outgoing.style.opacity = 0;

  front = 3 - front;
  primeHiddenLayer();
}

// --- Ìïú Ïä§ÌÖù Ï†ÑÌôò ----------------------------------------------------------
async function showNextPhoto(){
  if (!photoList.length) return;

  await ensurePreloaded();
  if (!preloadQueue.length) return;

  const now = Date.now();
  if (now < nextSwitchAt) return;

  const nextPhoto = preloadQueue[0];
  const { readyAt } = nextPhoto;
  if (now < readyAt) return;

  preloadQueue.shift();
  swapBackground(nextPhoto);
  nextSwitchAt = now + DISPLAY_INTERVAL_MS;

  // Î∞±Í∑∏ÎùºÏö¥Îìú ÌîÑÎ¶¨Î°úÎìú
  ensurePreloaded();
}

// --- ÌÉÄÏù¥Î®∏ Ïª®Ìä∏Î°§/Í∞ÄÏãúÏÑ± ÎåÄÏùë --------------------------------------------
function stopPhotoTimers(){
  if (slideTimer){ clearInterval(slideTimer); slideTimer = null; }
  if (refillTimer){ clearInterval(refillTimer); refillTimer = null; }
}
function startPhotoTimers(){
  if (!slideTimer){
    slideTimer = setInterval(showNextPhoto, DISPLAY_INTERVAL_MS);
  }
  if (!refillTimer){
    refillTimer = setInterval(async ()=>{
      if (isRefreshingPhotos){
        return;
      }
      isRefreshingPhotos = true;
      try{
        const changed = await loadPhotos();
        await ensurePreloaded();
        if (changed){
          nextSwitchAt = Date.now();
          showNextPhoto();
        }
      }finally{
        isRefreshingPhotos = false;
      }
    }, PHOTO_REFRESH_INTERVAL_MS);
  }
}
document.addEventListener('visibilitychange', ()=>{
  if (document.hidden){
    stopPhotoTimers();
  }else{
    nextSwitchAt = Date.now();
    startPhotoTimers();
  }
});

// --- Ï¥àÍ∏∞Ìôî(IIFE) -----------------------------------------------------------
(async ()=>{
  stopPhotoTimers();

  await loadPhotos(true);
  if (!photoList.length){
    return;
  }

  await ensurePreloaded();

  const b1 = document.getElementById('bg1');
  const b2 = document.getElementById('bg2');

  // Ï¥àÍ∏∞ 1Ïû• ÌôîÎ©¥ ÏÑ∏ÌåÖ(ÌÅêÏóêÏÑú ÏÜåÎπÑ)
  if (preloadQueue[0]){
    const first = preloadQueue.shift();
    applyBackgroundImage(b1, first);
    b1.style.opacity = 1;
    b2.style.opacity = 0;
    front = 1;
    nextSwitchAt = Date.now() + DISPLAY_INTERVAL_MS;
  }

  // Îã§Ïùå Ï†ÑÌôòÏö©ÏúºÎ°ú Ïà®ÍπÄ Î†àÏù¥Ïñ¥ ÎØ∏Î¶¨ ÏÑ∏ÌåÖ(ÏûàÎã§Î©¥)
  if (preloadQueue[0]){
    applyBackgroundImage(b2, preloadQueue[0]);
  }

  startPhotoTimers();
  primeHiddenLayer();
  showNextPhoto(); // Ï§ÄÎπÑÎêêÏúºÎ©¥ Î∞îÎ°ú 1Ìöå ÏãúÎèÑ
})();
</script>
</body>
</html>
